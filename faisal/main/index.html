<!DOCTYPE html>
 
<html>
    <head>
      <meta http-equiv="Cache-Control" content="no-cache">
      <script src="https://aframe.io/releases/1.0.4/aframe.min.js"></script>
      <script src="//cdn.rawgit.com/donmccurdy/aframe-physics-system/v4.0.1/dist/aframe-physics-system.min.js"></script>
      <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v6.1.0/dist/aframe-extras.min.js"></script>
      <script src="https://unpkg.com/aframe-teleport-controls@0.2.x/dist/aframe-teleport-controls.min.js"></script>
      <script src="https://unpkg.com/aframe-controller-cursor-component@0.2.x/dist/aframe-controller-cursor-component.min.js"></script>
      <script src="https://unpkg.com/super-hands@^3.0.1/dist/super-hands.min.js"></script>
      <script src="https://d3js.org/d3.v4.min.js"></script>
      <script>
        var shallThrow = false;
        var hasThrown = false;
        var ball;
        var lastPosition = new CANNON.Vec3(0, 0, 0);
        var currentPosition = new CANNON.Vec3(0, 0, 0);
        var hasPrepared = false;

        function throwBall(delta) {
            hasThrown = true;
            hasPrepared = false;
            let velocity = currentPosition.vsub(lastPosition).scale(1/delta);
            ball.body.applyLocalImpulse(velocity.scale(50), new CANNON.Vec3(0, 0, 0));
        }

        AFRAME.registerComponent('intersection-spawn', {
          schema: {
            default: '',
            parse: AFRAME.utils.styleParser.parse
          },
    
          init: function () {
            const data = this.data;
            const el = this.el;
    
            el.addEventListener(data.event, evt => {
              // Create element.
              const spawnEl = document.createElement('a-entity');
    
              // Snap intersection point to grid and offset from center.
              spawnEl.setAttribute('position', evt.detail.intersection.point);
              spawnEl.setAttribute('scale', {x: Math.random()*10, y: Math.random()*10, z: Math.random()*10});
              spawnEl.setAttribute('dynamic-body', 'mass: '+Math.random()*10);
              
    
              // Set components and properties.
              Object.keys(data).forEach(name => {
                if (name === 'event') { return; }
                AFRAME.utils.entity.setComponentProperty(spawnEl, name, data[name]);
              });
    
              // Append to scene.
              el.sceneEl.appendChild(spawnEl);
            });
          }
        });


        AFRAME.registerComponent('throwing-hand', {
            dependencies: ['dynamic-body', 'vive-controls'],
            init: function () {
                this.el.addEventListener('triggerdown', function (e) {
                    hasPrepared = true;
                    console.log('triggerdown');
                });
                this.el.addEventListener('triggerup', function (e) {
                    if (!hasThrown && hasPrepared) { shallThrow = true};
                    console.log('triggerup');
                });
                this.el.addEventListener('menuup', function (e) { // restart
                    hasThrown = false;
                    hasPrepared = false;
                    shallThrow = false;
                    lastPosition = new CANNON.Vec3(0, 0, 0);
                    currentPosition = new CANNON.Vec3(0, 0, 0);
                });

            },
            tick: function (uptime, delta) {
                let position = this.el.getAttribute('position');

                if (!hasThrown && ball && ball.body) {
                    ball.body.velocity.set(0, 0, 0);
                    ball.body.angularVelocity.set(0, 0, 0);
                    ball.body.quaternion.set(0, 0, 0, 1);
                    ball.body.position.set(position.x, position.y, position.z);
                }

                if (shallThrow && ball && ball.body) {
                    shallThrow = false;
                    currentPosition.copy(position);
                    throwBall(delta / 1000.0);
                }

                lastPosition.copy(position);
            }
        });

        window.onload = function () {
            ball = document.getElementById('ball');
            // make the ball not bounce when colliding with the ground or the bumpers

            let world = document.querySelector('a-scene').systems['physics'].world;
            let groundMaterial = document.querySelector('[static-body]').body.material;
            let laneObjects = document.querySelectorAll(['static-body']);
            for (let i = 0; i < laneObjects.length; i++) {
                laneObjects[i].body.material = groundMaterial;
            }
        };
      </script>

    </head>
 
  <body>
    <a-scene physics="gravity: -1.6" renderer="antialias: true">
      <a-assets>
        <img id="groundTexture" src="images/brick.jpg">
        <img id="skyTexture" src="images/darksky.jpg">
        <a-mixin id="voxel"
        dynamic-body="mass: 1"
        geometry="primitive: box; height: 0.5; width: 0.5; depth: 0.5"
        material="shader: standard"
        random-color
        snap="offset: 0.25 0.25 0.25; snap: 0.5 0.5 0.5"
      ></a-mixin>
      </a-assets>


      <a-entity camera look-controls wasd-controls></a-entity>

      <!-- <a-entity controller-cursor intersection-spawn="event: click; mixin: voxel" static-body sphere-collider="objects: a-box" super-hands hand-controls="hand: right"></a-entity> -->
      
      <a-entity
        id="leftController"
        static-body="shape: sphere; sphereRadius: 0.02;"
        vive-controls="hand: left"
        super-hands hand-controls="hand: left"
        sphere-collider="objects: .throwable"
        intersection-spawn="event: click; mixin: voxel"
      ></a-entity>
      <a-entity
        id="rightController"
        static-body="shape: sphere; sphereRadius: 0.02;"
        vive-controls="hand: right"
        super-hands hand-controls="hand: right"
        sphere-collider="objects: .throwable"
        grab
      ></a-entity>

      <!-- Ammo -->
      <a-sphere class="throwable" dynamic-body position="0 0.25 -0.5" radius="0.10" color="green"></a-sphere>
      <a-sphere class="throwable" dynamic-body position="0.25 0.25 -0.5" radius="0.10" color="yellow"></a-sphere>
      <a-sphere class="throwable" dynamic-body position="-0.25 0.25 -0.5" radius="0.10" color="yellow"></a-sphere>
      <a-sphere class="throwable" dynamic-body position="-0.651 1.8 -0.5" radius="0.10" color="yellow"></a-sphere>
      <a-sphere class="throwable" dynamic-body position="-1.25 1.8 -0.5" radius="0.10" color="green"></a-sphere>
      <a-sphere class="throwable" dynamic-body position="0.96 1.6 -0.5" radius="0.10" color="yellow"></a-sphere>

      <!--Table to hold the targets -->
      <a-box
        static-body
        position="2 1 0"
        width="2"
        height="0.1"
        depth="2"
        color="grey"
      ></a-box>

      <a-box position="0 0.25 10.5" width="2" height="4" color="red"></a-sphere>

      <!-- The targets (will be generated with D3) -->
      <a-entity id="boxes"></a-entity>

      <!-- Ground -->
      <!-- <a-plane
        static-body
        rotation="-90 0 0"
        width="10"
        height="10"
        color="black"
      ></a-plane> -->
      <a-cylinder static-body id="ground" src="#groundTexture" radius="30" height="0.1" position="0 -0.2 0"></a-cylinder>
      <a-ocean width="50" depth="50" density="40"></a-ocean>

      <!-- Sky -->
      <a-sky color="#ECECEC"></a-sky>
    </a-scene>
  </body>

  <script>
    const colorScale = d3.scaleSequential(d3.interpolatePlasma);
    const dataset = [];
  
    for (let i = 10; i > 0; i--) {
      dataset.push(i);
    }
  
    let boxes = d3.select('#boxes');
    boxes.selectAll('a-box')
         .data(dataset)
         .enter()
         .append('a-box')
         .attr('height', '0.1')
         .attr('width', function(d, i) {
           return String(0.1 * d);
         })
         .attr('depth', function(d, i) {
           return String(0.1 * d);
         })
         .attr('color', function(d, i) {
           return colorScale(i / 10);
         })
         .attr('position', function(d, i) {
           return '2 ' + (i * 0.1 + 1.1) + ' 0';
         })
         .attr('dynamic-body', '');


        setInterval(function() {
          console.log('asd');
        }, 1000); 
  </script>


<script>
  setTimeout(() => {
  // let box = document.querySelector('a-boxs');

  // box.setAttribute('zoom-front-camera', 'zooming', true);

}, 2000);


const THREE = window.THREE
const degToRad = window.THREE.Math.degToRad

let animationPlaying = false
let animationCompleted = false

AFRAME.registerComponent('zoom-front-camera', {

  schema: {
    zooming: {
      type: 'boolean'
    },
  },

  _cameraEntity: null, //Camera Entity

  _threeElement: null, //this.el in ThreeJS (Object3D)
  _threeCamera: null, //Camera entity in ThreeJS (Object3D)
  _initialQuaternion: null, //Initial Quaternion property
  _initialPosition: null, //Initial Position property
  _targetQuaternion: null, //Target Quaternion property
  _targetPosition: null, //Target Position property

  //Initialize var, add the event listeners & call the function to change element position
  init: function() {
    this._cameraEntity = this.el.sceneEl.camera.el

    this.el.addEventListener('animation__position-begin', function() {
      animationPlaying = true
    })

    this.el.addEventListener('animation__position-complete', function() {
      animationPlaying = false
      animationCompleted = true
    })

    this.retrieveDatas()
  },

  update: function() {
    return (this.data.zooming) ? this.tweenHotspotToCamera() : this.tweenHotspotToCamera(true)
  },

  //Loop Function to update the rotation of the element during the position changement (by using Quaternion)
  tick: function() {

    if (animationCompleted) {

      //Dezoom && Animation Completed => so we hide the image
      if (!this.data.zooming) {
        this.el.setAttribute('visible', false)

        //Remove component to avoid keep ticking
        this.el.removeAttribute('zoom-front-camera')
      }

      //Bind reversed zoom event on click
      let clickEvent = {
        'zoom-front-camera.zooming': !this.data.zooming,
      }

      this.el.setAttribute('event-set__click', clickEvent)

      //Reinitialize animation
      animationCompleted = false
      return
    }

    if (!animationPlaying)
      return

    return (this.data.zooming) ?
      this.slerpEffect(this._initialPosition, this._targetPosition, this._initialQuaternion, this._targetQuaternion) :
      this.slerpEffect(this._targetPosition, this._initialPosition, this._targetQuaternion, this._initialQuaternion)
  },

  retrieveDatas: function() {
    this._threeElement = this.el.object3D
    this._threeCamera = this._cameraEntity.object3D

    //Copy the initial datas
    this._initialPosition = this._threeElement.position.clone()
    this._initialQuaternion = this._threeElement.quaternion.clone()

    //Some maths to obtain objects around the same size of the screen

    //Retrieving the Field of View (FOV) from the camera attribute
    const {
      fov
    } = this._cameraEntity.getAttribute('camera')

    //Convert fov + reduce it
    let fovInRad = degToRad(fov) / 2
    let ratio = window.innerWidth / window.innerHeight //Assuming the FOV is vertical
    let pLocal, cPos

    let bbox = getCompoundBoundingBox(this._threeElement)
    let sizeY = bbox.max.y - bbox.min.y
    let sizeX = bbox.max.x - bbox.min.x

    sizeX *= this._threeElement.scale.x
    sizeY *= this._threeElement.scale.y

    let tanFov = Math.tan(fovInRad)
    let distY = sizeY / tanFov
    let distX = ((sizeX / (ratio * tanFov)) < distY) ? distY : sizeX / (ratio * tanFov)

    pLocal = new THREE.Vector3(0, 0, -distX)

    cPos = this._threeCamera.position.clone()
    cPos.y -= 1.5

    //Apply the direction the camera is facing
    this._targetPosition = pLocal.applyMatrix4(this._threeCamera.matrixWorld)
		console.log(this._targetPosition)
    
    let targetLook = cPos.applyMatrix4(this._threeCamera.matrixWorld)
    this._threeElement.position.copy(this._targetPosition)
    this._threeElement.lookAt(targetLook)
    this._targetQuaternion = this._threeElement.quaternion.clone()

    //Take the original data back
    this._threeElement.position.copy(this._initialPosition)
    this._threeElement.quaternion.copy(this._initialQuaternion)
  },

  tweenHotspotToCamera: function(reversed = false) {
          console.log(this.el.parentNode)
          var pos = this.el.parentNode.getAttribute("position")
					this._targetPosition.x -= pos.x
					this._targetPosition.y -= pos.y
					this._targetPosition.z -= pos.z

    //Animation
    const positionAnimation = {
      property: 'position',
      from: this._threeElement.position,
      to: (reversed) ? this._initialPosition : AFRAME.utils.clone(this._targetPosition),
      dur: 2000,
      easing: 'easeInOutCubic',
      startEvents: ['---non-existent-event---'], //Avoid auto-play of the animation
    }

    //Set the animation on the element
    this.el.setAttribute('animation__position', positionAnimation)

    //Retrieve the animation
    const {
      animation
    } = this.el.components.animation__position

    if (animation)
      animation.play()
  },

  slerpEffect: function(initialP, finalP, initialQ, finalQ) {
    let dstF = initialP.distanceTo(finalP)
    let dstC = initialP.distanceTo(this._threeElement.position)
    let k = dstC / dstF

    THREE.Quaternion.slerp(initialQ, finalQ, this._threeElement.quaternion, k)

    //Because few images are disappearing when you click on them
    this.el.setAttribute('visible', true)
  },
})

/**
 * Get the size of the given object
 *
 * @param object3D
 * @returns {*}
 */
function getCompoundBoundingBox(object3D) {
  let box = null
  object3D.traverse(function(obj3D) {
    let geometry = obj3D.geometry
    if (geometry === undefined) return
    geometry.computeBoundingBox()
    if (box === null)
      box = geometry.boundingBox
    else
      box.union(geometry.boundingBox)
  })
  return box
}

</script>


</body>
</html>