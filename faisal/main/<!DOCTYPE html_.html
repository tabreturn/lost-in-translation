<!DOCTYPE html>
 
<html>
    <head>
      <meta http-equiv="Cache-Control" content="no-cache">
      <script src="https://aframe.io/releases/1.0.4/aframe.min.js"></script>
      <script src="//cdn.rawgit.com/donmccurdy/aframe-physics-system/v4.0.1/dist/aframe-physics-system.min.js"></script>
      <script src="https://cdn.jsdelivr.net/gh/donmccurdy/aframe-extras@v6.1.0/dist/aframe-extras.min.js"></script>
      <script src="https://unpkg.com/aframe-teleport-controls@0.2.x/dist/aframe-teleport-controls.min.js"></script>
      <script src="https://unpkg.com/aframe-controller-cursor-component@0.2.x/dist/aframe-controller-cursor-component.min.js"></script>
      <script src="https://unpkg.com/super-hands@^3.0.1/dist/super-hands.min.js"></script>
      <script>

        //color randomizer
      AFRAME.registerComponent('color-randomizer', {
        play: function () {
          this.el.addEventListener('drag-drop', function (evt) {
            evt.detail.dropped.setAttribute('material', 'color',
              '#'+(Math.random()*0xFFFFFF<<0).toString(16))
          })
        }
      })

      
        // turn controller's physics presence on only while button held down
        AFRAME.registerComponent('phase-shift', {
          init: function () {
            var el = this.el
            el.addEventListener('gripdown', function () {
              el.setAttribute('collision-filter', {collisionForces: true})
            })
            el.addEventListener('gripup', function () {
              el.setAttribute('collision-filter', {collisionForces: false})
            })
          }
        })
        
        AFRAME.registerComponent('random-color', {
          dependencies: ['material'],
    
          init: function () {
            this.el.setAttribute('material', 'color', getRandomColor());
          }
        });
    
        AFRAME.registerComponent('snap', {
          dependencies: ['position'],
          schema: { offset: {type: 'vec3'}, snap: {type: 'vec3'} },
    
          init: function () {
            this.originalPos = this.el.getAttribute('position');
          },
    
          update: function () {
            const data = this.data;
    
            const pos = AFRAME.utils.clone(this.originalPos);
            pos.x = Math.floor(pos.x / data.snap.x) * data.snap.x + data.offset.x;
            pos.y = Math.floor(pos.y / data.snap.y) * data.snap.y + data.offset.y;
            pos.z = Math.floor(pos.z / data.snap.z) * data.snap.z + data.offset.z;
    
            this.el.setAttribute('position', pos);
          }
        });
    
        AFRAME.registerComponent('intersection-spawn', {
          schema: {
            default: '',
            parse: AFRAME.utils.styleParser.parse
          },
    
          init: function () {
            const data = this.data;
            const el = this.el;
    
            el.addEventListener(data.event, evt => {
              // Create element.
              const spawnEl = document.createElement('a-entity');
    
              // Snap intersection point to grid and offset from center.
              spawnEl.setAttribute('position', evt.detail.intersection.point);
              spawnEl.setAttribute('scale', {x: Math.random()*10, y: Math.random()*10, z: Math.random()*10});
              spawnEl.setAttribute('dynamic-body', 'mass: '+Math.random()*10);
              
    
              // Set components and properties.
              Object.keys(data).forEach(name => {
                if (name === 'event') { return; }
                AFRAME.utils.entity.setComponentProperty(spawnEl, name, data[name]);
              });
    
              // Append to scene.
              el.sceneEl.appendChild(spawnEl);
            });
          }
        });

        AFRAME.registerComponent('dragging', {
          schema: {
            default: '',
            parse: AFRAME.utils.styleParser.parse
          },
          init: function () {
            console.log(this.data);
          }
        });
    
    
        function getRandomColor() {
          const letters = '0123456789ABCDEF';
          var color = '#';
          for (var i = 0; i < 6; i++ ) {
            color += letters[Math.floor(Math.random() * 16)];
          }
          return color;
        }

        navigator.mediaDevices.getUserMedia({audio: false, video: true})
        .then(stream => {
          let $video = document.querySelector('video')
          $video.srcObject = stream
          $video.onloadedmetadata = () => {
            $video.play()
          }
        })
      </script>
    </head>
 
  <body>
    
  <a-scene physics='gravity: -9.8' antialias='true' environment="preset: tron; shadow: true">
    <a-assets>
      <a-mixin id="pointer" raycaster="showLine: true; objects: .cube, a-link"
                  super-hands="colliderEvent: raycaster-intersection;
                                colliderEventProperty: els;
                                colliderEndEvent:raycaster-intersection-cleared;
                                colliderEndEventProperty: clearedEls;">
      </a-mixin>
      <a-mixin id="controller-right" mixin="pointer"
                vive-controls="hand: right" oculus-touch-controls="hand: right"
                windows-motion-controls="hand: right"
                gearvr-controls daydream-controls oculus-go-controls>
      </a-mixin>
      <a-mixin id="controller-left" mixin="pointer"
                vive-controls="hand: left" oculus-touch-controls="hand: left"
                windows-motion-controls="hand: left">
      </a-mixin>
      <a-mixin id="cube" geometry="primitive: box; width: 0.5; height: 0.5; depth: 0.5"
                hoverable grabbable stretchable draggable droppable
                shadow
                event-set__dragdrop="_event: drag-drop; geometry.primitive: sphere; geometry.radius: 0.25"
                event-set__hoveron="_event: hover-start; material.opacity: 0.7; transparent: true"
                event-set__hoveroff="_event: hover-end; material.opacity: 1; transparent: false"
                event-set__dragon="_event: dragover-start; material.wireframe: true"
                event-set__dragoff="_event: dragover-end; material.wireframe: false">
      </a-mixin>


      <img id="groundTexture" src="images/brick.jpg">
      <img id="skyTexture" src="images/darksky.jpg">
      <img id="colortransform" src="images/arrow.png" />
      <a-mixin id="voxel"
        dynamic-body="mass: 1"
        geometry="primitive: box; height: 0.5; width: 0.5; depth: 0.5"
        material="shader: standard"
        random-color
        snap="offset: 0.25 0.25 0.25; snap: 0.5 0.5 0.5"
      ></a-mixin>
      <a-mixin id="transformer" color-randomizer droppable static-body
                  collision-filter="collisionForces: false"
                  event-set__dragon="_event: dragover-start; material.wireframe: true"
                  event-set__dragoff="_event: dragover-end; material.wireframe: false"
                  geometry="primitive: box; width: 0.5; height: 0.5; depth: 0.5"></a-mixin>

      <a-mixin id="touch"
        physics-collider phase-shift
        collision-filter="collisionForces: false"
        static-body="shape: sphere; sphereRadius: 0.02"
        super-hands="colliderEvent: collisions;
                  colliderEventProperty: els;
                  colliderEndEvent: collisions;
                  colliderEndEventProperty: clearedEls;">
      </a-mixin>
      <video id="webcam" playsinline></video>
    </a-assets>

    <a-cylinder static-body id="ground" src="#groundTexture" radius="30" height="0.1" position="0 -0.2 0"></a-cylinder>
    <a-sky id="background" src="#skyTexture" theta-length="90" radius="30"></a-sky> -->
    <a-cylinder radius="0.05" height="0.3" position="0 0.15 -5" color="#ccc" dynamic-body="mass: 1"></a-cylinder>

    <a-sphere class="throwable" dynamic-body position="0 0.25 -0.5" radius="0.10" color="green"></a-sphere>
    <a-box hoverable grabbable stretchable draggable dropppable color="blue" position="5 0 -1"></a-box>

    <!-- mixin -->
    <a-entity class="cube" mixin="cube" position="0 0.265 -1" material="color: red"></a-entity>
    <a-entity class="transformer" mixin="transformer" position = "0 1.6 -1" material="src:#colortransform" shadow></a-entity>

    <a-box dynamic-body position="0 0.15 -5" width="1" height="1" depth="1"></a-box>
    <a-cylinder radius="0.05" height="0.3" position="-0.2 0.15 -5.2" color="#ccc" dynamic-body="mass: 1"></a-cylinder>
    <a-sphere position="0 1.25 -5" radius="50" color="#ffffff" shadow material="side: double; src: #webcam"></a-sphere>


    <a-entity class="cube" mixin="cube" position="0 1 -1.25" material="color: red"></a-entity>

    <a-ocean width="50" depth="50" density="40"></a-ocean>
    
    
    <!-- Hands. -->
    <a-entity>
        <a-entity id="rhand" mixin="controller-right"></a-entity>
        <a-entity id="lhand" mixin="controller-left"></a-entity>
    </a-entity>
    <a-entity static-body sphere-collider="objects: a-box" super-hands hand-controls="hand: left"></a-entity>
    <a-entity controller-cursor intersection-spawn="event: click; mixin: voxel" static-body sphere-collider="objects: a-box" super-hands hand-controls="hand: right"></a-entity>
    
    
    <!-- <a-entity id="teleHand" laser-controls="left" teleport-controls="type: parabolic; collisionEntities: [mixin='voxel'], #ground"></a-entity> -->
    <!-- <a-entity id="blockHand" laser-controls="right" controller-cursor intersection-spawn="event: click; mixin: voxel"></a-entity> -->

    <!-- Camera. -->
    <a-camera>
      <a-cursor intersection-spawn="event: click; mixin: voxel"></a-cursor>
    </a-camera>
  </a-scene>



</body>
</html>